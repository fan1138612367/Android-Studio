<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="256" />
    <option name="newTranslationDialogWidth" value="584" />
    <option name="newTranslationDialogX" value="623" />
    <option name="newTranslationDialogY" value="342" />
    <histories>
      <item value="Creates an instance of a cold Flow with elements that are sent to a SendChannel provided to the builder's block of code via ProducerScope. It allows elements to be produced by code that is running in a different context or concurrently. The resulting flow is cold, which means that block is called every time a terminal operator is applied to the resulting flow. This builder ensures thread-safety and context preservation, thus the provided ProducerScope can be used concurrently from different contexts. The resulting flow completes as soon as the code in the block and all its children completes. Use awaitClose as the last statement to keep it running. A more detailed example is provided in the documentation of callbackFlow. A channel with the default buffer size is used. Use the buffer operator on the resulting flow to specify a user-defined value and to control what happens when data is produced faster than consumed, i.e. to control the back-pressure behavior. Adjacent applications of channelFlow, flowOn, buffer, and produceIn are always fused so that only one properly configured channel is used for execution. Examples of usage:" />
      <item value="Exception in thread &quot;main&quot; java.lang.IllegalStateException: Flow invariant is violated: Flow was collected in EmptyCoroutineContext, but emission happened in [DispatchedCoroutine{Active}@3c377f7f, Dispatchers.IO]. Please refer to 'flow' documentation or use 'flowOn' instead" />
      <item value="This declaration is experimental and its usage should be marked with '@kotlinx.coroutines.ExperimentalCoroutinesApi' or '@OptIn(kotlinx.coroutines.ExperimentalCoroutinesApi::class)'" />
      <item value="Continuation" />
      <item value="Sends the specified element to this channel, suspending the caller while the buffer of this channel is full or if it does not exist, or throws an exception if the channel is closed for send (see close for details). Closing a channel after this function has suspended does not cause this suspended send invocation to abort, because closing a channel is conceptually like sending a special &quot;close token&quot; over this channel. All elements sent over the channel are delivered in first-in first-out order. The sent element will be delivered to receivers before the close token. This suspending function is cancellable. If the Job of the current coroutine is cancelled or completed while this function is suspended, this function immediately resumes with a CancellationException. There is a prompt cancellation guarantee. If the job was cancelled while this function was suspended, it will not resume successfully. The send call can send the element to the channel, but then throw CancellationException, thus an exception should not be treated as a failure to deliver the element. See &quot;Undelivered elements&quot; section in Channel documentation for details on handling undelivered elements. Note that this function does not check for cancellation when it is not suspended. Use yield or CoroutineScope.isActive to periodically check for cancellation in tight loops if needed. This function can be used in select invocations with the onSend clause. Use trySend to try sending to this channel without waiting." />
      <item value="Marks the annotated declaration as deprecated. A deprecated API element is not recommended to use, typically because it's being phased out or a better alternative exists. To help removing deprecated API gradually, the property level could be used. Usually a gradual phase-out goes through the &quot;warning&quot;, then &quot;error&quot;, then &quot;hidden&quot; or &quot;removed&quot; stages: First and by default, DeprecationLevel.WARNING is used to notify API consumers, but not to break their compilation or runtime usages. Then, some time later the deprecation level is raised to DeprecationLevel.ERROR, so that no new Kotlin code can be compiled using the deprecated API. Finally, the API is either removed entirely, or hidden (DeprecationLevel.HIDDEN) from code, so its usages look like unresolved references, while the API remains in the compiled code preserving binary compatibility with previously compiled code." />
      <item value="Marks the annotated declaration as deprecated. In contrast to Deprecated, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the -api-version argument when compiling the module where the usage is located). If the API version is greater or equal than hiddenSince, the declaration will not be accessible from the code (as if it was deprecated with level DeprecationLevel.HIDDEN), otherwise if the API version is greater or equal than errorSince, the usage will be marked as an error (as with DeprecationLevel.ERROR), otherwise if the API version is greater or equal than warningSince, the usage will be marked as a warning (as with DeprecationLevel.WARNING), otherwise the annotation is ignored." />
      <item value="login Cellphone" />
      <item value="When LaunchedEffect enters the composition it will launch block into the composition's CoroutineContext. The coroutine will be cancelled and re-launched when LaunchedEffect is recomposed with a different key1. The coroutine will be cancelled when the LaunchedEffect leaves the composition. This function should not be used to (re-)launch ongoing tasks in response to callback events by way of storing callback data in MutableState passed to key1. Instead, see rememberCoroutineScope to obtain a CoroutineScope that may be used to launch ongoing jobs scoped to the composition in response to event callbacks." />
      <item value="Tertiary" />
      <item value="the state object to be used to control or observe the list's state." />
      <item value="Experimental Serialization Api" />
      <item value="Type checking has run into a recursive problem. Easiest workaround: specify types of your declarations explicitly" />
      <item value="Json Configuration" />
      <item value="conf" />
      <item value="Creates an instance of Json configured from the optionally given Json instance and adjusted with builderAction." />
      <item value="with Transaction" />
      <item value="Calls the specified suspending block in a database transaction. The transaction will be marked as successful unless an exception is thrown in the suspending block or the coroutine is cancelled. Room will only perform at most one transaction at a time, additional transactions are queued and executed on a first come, first serve order. Performing blocking database operations is not permitted in a coroutine scope other than the one received by the suspending block. It is recommended that all Dao function invoked within the block be suspending functions. The dispatcher used to execute the given block will utilize threads from Room's query executor." />
      <item value="refusing to merge unrelated histories" />
      <item value="Using 'GridCells' is an error. GridCells was moved to .grid subpackage" />
      <item value="encrypt We API" />
      <item value="Filled Tonal Icon Button" />
      <item value="weight" />
      <item value="Scale" />
      <item value="animated Fab Scale" />
      <item value="Align the element horizontally within the Column. This alignment will have priority over the Column's horizontalAlignment parameter. Example usage:" />
      <item value="Cannot use 'T' as reified type parameter. Use a class instead." />
      <item value="Value class cannot have properties with backing fields" />
      <item value="Value classes without @JvmInline annotation are not supported yet" />
      <item value="Primary constructor is required for value class" />
      <item value="Inline class must have exactly one primary constructor parameter" />
      <item value="saved Instance State" />
      <item value="contains references to both AndroidX and old support library. This seems like the library is partially migrated. Jetifier will try to rewrite the library anyway" />
      <item value="set Is Can Touch" />
      <item value="Minimum and maximum scroll positions. The minimum scroll position is generally zero and the maximum scroll position is generally the content size less the screen size. So if the content width is 1000 pixels and the screen width is 200 pixels, the maximum scroll offset should be 800 pixels." />
      <item value="on Double Tap" />
      <item value="start Scale Up" />
      <item value="request Disallow Intercept Touch Event" />
      <item value="判断内容是否相同" />
      <item value="Custom view `ImageView` has setOnTouchListener called on it but does not override performClick" />
      <item value="Gesture Listener" />
      <item value="On Double Tap Listener" />
      <item value="On Scale Gesture Listener" />
      <item value="On Gesture Listener" />
      <item value="Spannable String" />
      <item value="internal" />
      <item value="All illegal access operations will be denied in a future release" />
      <item value="WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by retrofit2.Platform (file:C:UsersFan.gradlecachesmodules-2files-2.1com.squareup.retrofit2retrofit2.9.0d8fdfbd5da952141a665a403348b74538efc05ffretrofit-2.9.0.jar) to constructor java.lang.invoke.MethodHandlesLookup(java.lang.Class,int) WARNING: Please consider reporting this to the maintainers of retrofit2.Platform WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release" />
      <item value="Exception in thread" />
      <item value="Exception" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="70" />
        <entry key="ENGLISH" value="67" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1651324327027" />
  </component>
  <component name="Settings">
    <option name="translateDocumentation" value="true" />
  </component>
</application>